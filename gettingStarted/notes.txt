OpenGL
_____________________________________________________________-

- OpenGL by itself is not an API but merly a specification developed by Khronos Group

- OpenGL is just a specification that specifies what result/output each function should have. The actual implementation of 
  open gl is implemented by the graphics cards 

- It's advised to update your drivers so that you can fix any bugs with open gl caused by the graphics card manufactured 

- Immidiate Mode (Fixed Function Pipeline): An older specification of open gl that was easy to use and most functions were hidden inside the library 

- Core Profile Mode: The modern version of openGL, it gives more freedom to the programmer and is less abstract then the immidiate mode 

- OpenGL moved away from Immidiate Mode in version 3.3, because it was less efficient

- Open GL 3.3 is considered the "Modern Version" and all futere versions just optimize it 

- Programmers usually use depricated versions of open gl because only the most modern graphics cards can run the latest version 

- Extesuibs are optimizations in rendering by individual drivers 

- OpenGL is a large state machine 

- The state is called the "context"

- Whenever we want openGL to draw lines instead of triangles, we change the state using a "state-changing" function,
  Then we use "State-Using Functions" to use them 

- "Object": A collection of options that Represent a subset of OpenGL's state
        Ex)
            struct object_name {
                float  option1;
                int    option2;
                char[] name;
            };

- We can create custom objects with options that we can set in the program 


Creating a window
_____________________________________________________________-

- GFLW: A library written in C that gives us the bare necessities required. It allows us to make a simple window

- CMAKE can generate project files of users chouce from a collection of source code files using pre-defined CMake scripts 

- In order to use GLFW we need to link the library

- V++ Directories: Where we include libraries 

- GLAD: A library that helps retriev OS Specific locations for our GPUs open gl functions 

Hello Window
_____________________________________________________________-

- Callback: A function used in event driven programming, it's not called by the programmer, but called when the user does something,
              ie: Resize window, move joystick etc.

- Render Loop: Keeps window open until told to stop

Hello Triangle 
_____________________________________________________________-

- Graphics Pipeline: Transforms 3D coordinates to 2D Coordinates, then draws the pixels to the screen

- The graphics pipeline has several steps, and each step passes into the one after it

- Shaders: Small Programs that run on GPU for each step of graphic pipeline

- Vertex: Collection of data per 3D coordinate

- Vertex Attributes: Data in a vertex 

- Primitives: Hints we give to openGL on what to draw

- Vertex Shader: First part of graphics pipeline, takes a single vertex and it's main purpose is to transform 3D coordinates to 
                 different 3D coordinates 

- Geomotry Shader: Second part of graphics pipeline. It takes an input collection of verticies that form a primitive and has the 
                   ability to generate other shapes by emitting new verticies 

- Primitive Assembly: Third stage of graphics pipeline. takes input of all vertices from the vertex shader that form one or more primitives 
                      and assembles the points in a primitive shape given 

- Rastizeration Stage: Fourth step of graphics pipeline, it maps the primitives to coresponding pixels on screen, resulting in Fragments 
                       for the fragment shader to use. Before fragment shader runs clipping is performed, which discards all pixels off 
                       the screen to help performance 

- Fragment Shader: Fith step of Graphics Pipeline. Calculates the final color of a pixel, usually where advanced graphics occur. 

- Alpha Test and Blending Stage: Sixth and final stage of graphics pipeline, checks the corresponding depth value of the fragment
                                 and used those to check if the resulting fragment is in front or behind other objects and should 
                                 be discarded accordingly. Also checks alpha values and blends accordingly

- Fragment: All the data required for OpenFL to render a Single Pixel 

- Nomalized Device coordinates: x,y,z coords in range -1.0 -> 1.0

- Vertex Buffer Object (VBO): Can store large numbers of verticies in the GPU's memory

- GPU Draw Hints for flBudderData
  GL_STREAM_DRAW: the data is set only once and used by the GPU at most a few times.
  GL_STATIC_DRAW: the data is set only once and used many times.
  GL_DYNAMIC_DRAW: the data is changed a lot and used many times.

- Shader Program Object: Final linked version of multiple shaders combined 


- Vertex Array Object (VAO): Can be bound just like a buffer and any subsequent vertex attribute calls will be stored inside the VAO.

- Element Buffer Object (EBO): Stores indicies that openGL uses to decide what vertices to draw


Shaders
_____________________________________________________________-

- Shaders are little programs in the GPU that make up the graphics pipeline

- Shaders are isolated programs, there not allowed to communicate with each other 

- Shaders are written in GLSL 

- GLSL: A see like language used for graphics programming, it's usefull because it has usefull features for targeting vector and matrix manipulation 

- Shader Ex:
    #version version_number
    in type in_variable_name;
    in type in_variable_name;

    out type out_variable_name;
      
    uniform type uniform_name;
      
    void main()
    {
      // process input(s) and do some weird graphics stuff
      ...
      // output processed stuff to output variable
      out_variable_name = weird_stuff_we_processed;
    }

- Vertex Attribute: Input for each shader 

- Vector: A 2, 3, 4 component container for any of the basic types just mentioned 

- Swizzling: Flexible component selection 
    Ex:
      vec2 someVec;
      vec4 differentVec = someVec.xyxx;
      vec3 anotherVec = differentVec.zyw;
      vec4 otherVec = someVec.xxxx + anotherVec.yxzy;

    Ex:
      vec2 vect = vec2(0.5, 0.7);
      vec4 result = vec4(vect, 0.0, 0.0);
      vec4 otherResult = vec4(result.xyz, 1.0);

- in/out Keywords: Used to define inputs and outputs in GLSL

- Uniforms: Another way to pass data from our program on the CPU to our GPU, Uniforms are global 
            meaning it is unique per shader program object and can be accessed by any shader at any 
            stage of the programs execution 

- If you declare uniform not used anywhere then the compiler will silently remove it, wich can cause several errors 


Textures 
_____________________________________________________________-

- An image used to add detail to an object 

- Sampling: Retreiving a texture color using texture coordinates 

- GL_LINEAR (Nearest Neighbor): The default texture filtering method. When set OpenGL selects the textel that center is 
                                closest to the texture coordinate.

- GL_LINEAR (Bilinear filtiring): Takes an interpolated falue from a texture coordinates neighboring textels, approximating
                                  the color 

- GL_NEAREST will give a sort of 8-bit blocky look 

- MiniMaps: A collection of texture images where each texture is twice as small as compared to the other one. When a object 
            is a certain threashhold awy, opengl will use a different mini-map texture that best suits the object 

- glGenerateMinimap: This is a function that helps us generate all mini maps down to one pixel 

- OpenGL should have a at least a minimum of 16 texture units for you to use which you can activate using GL_TEXTURE0 to 
  GL_TEXTURE15. They are defined in order so we could also get GL_TEXTURE8 via GL_TEXTURE0 + 8 


Transformations
_____________________________________________________________-

- Vectors: Directions on a graph with 2 charectreistics (Direction and Magnitude)

- Scaler: A single digit. When adding/subtracting/multiplying/dividing a scaler we simply do the operation to each element in the vector 

- Negation: Negating a vector makes the vector point the oppisite direction 

- For vector addition we add each element of each vector

- Subtracting 2 vectors from each other results in a vector thats the difference of the positions between both vectors

- Use pythagorus theorum to retreive the magnitude/ length of a vector

- Unit Vector (n^): Has one extra property, that it's length is exactly 1

- Normalizing: We can calculate a unit vector from any vector by dividing each of the vectors components by it's length

- Normal Multipication isnt really defined on vectors since it has no visual meaning

- Dot Product: The scalar product of their lengths times the cosine of the angle between them 
      Ex:
          0.6        0
          -0.8.  *   1 = (0.6*0) + (-0.8 * 1) + (0 * 0) = -0.8 
          0          0

- cosine function becomes 0 when the angle is 90 degrees, or 1 when the angle is 0. This allows us to test if the 
  vectors are orthogonal (Thry form a right angle to each other). 


- Cross Product: Only defined in 3D space and takes 2 non parrllel vectors and produces a third vector that is orthagonal to both 

- Matrix: A rectangular array of numbers symbols and mathmatical expressions

- Matrixes need to hace same rows and colomns to be added and subtracted 

- Rules for Multiplying Matricies:
    1 - You can only multiply 2 matricies if the number of columns on the left hand side is equal to the number of rows on the 
        right hand side
    2 - Matrix Multipication is not Commutative A * B != B * A

- Vector: A Nx1 Matrix

- Identity Matrix: A matrix of all 0's except on the diagnal 

- Uniform Scale: When scaling is equal on all axeses 

- Adding a another vector to return a new vector with a different position 

- homogeneous coordinate (w): This coordinate helps us do transformations on 3D vectors 

- Matrix multiptication is not communative, meaning multipication order matters 

- GLM (OpenGL Mathmatics): A header only library for Open Gl Math


Coordinate Systems
_____________________________________________________________-

- Normalized Device Coordinates (NDC): The coordinates OpenGL uses from -1 to 1

- Bellow are the 6 stages of coordinates 

- Local Space: The coordinate space that is local to your object, where the object begins in. 

- World Space: The verticies of all your virticies relative to the game world. The coordinates of Local Space are transformed 
               to world space using the model matrix

        - Model Matrix - A transformation matrix that scales, translates, rotates your object to a place it belongs to

- View Space: What people usually refer to as the Camera of OpenGL, sometimes it's called the camera space. It is responsable 
              for transforming the world space to something in the users view.

- Clip Space: Any coordinates that fall outside of the specified range are "clipped", meaning they are discarder and not 
              sent to fragment shader.


        - Projection Matrix - Specifies a range of coordinates (Say -1000->1000) in each dimension, then the a stage called perspective
                              division converts the coordinates to normalized coordinates bettween -1,1. say we have a coordinate 
                              (1200, 500, 759), this will be clipped, because it's x is out of range.

        - Frustum: Each coordinate in here will end up on the users screen.  


        - Perspective Division: We divie x, y, and z coordinates of a position vector by a vectors w component, and transform the 4D clip space 
                                to a 3D normalized device coordinate. 
  
- Orthagraphic Projection: Defines a cube like frustum box that defines the clipping space where each vertex outside this box is clipped. 
                
                - glm::ortho(float, float, float, float, float, float):
                        . First 2 Parameters: Left and Right of the frustrum 
                        . 3rd and 4th parameters: Specify the bottom and top of frustrum 
                        . 5th and 6th parameters specify thedistance betwee the far planes of the frustrum 


- Perspective Projection: Maps a given Frustum range to clip a space, but also manipulates the w value of each vertex 
                          coordinate in such a way that the durther a vertex coordinate is away from the viewer, the 
                          higher the w is   


                - glm::mat4 proj = glm::perspective(glm::radians(45.0f, (float)width/(float)height), 0.1f, 100.0f)
                                                        FOV                   Aspect Ratio           Near   Far



- Because orthagraphic projection doesnt have perspective projection objects farther away don't seem smaller, which has weird visual output

Vclip = Mprojection * Mview * Mmodel * Vlocal

- Model Matrix: Consists of trnslations, scaling, and rotations we want to apply to all verticies in the global space 

- View Matrix: We move the whole scene around inversed to where we want the camera to move 

- Right Hand System: Posative X is right, Posative Y is Up, And Posative Z is Backwards 

- Z-Buffer: Stores all the depth information, we can configure the z buffer to do depth testing


Camera
_____________________________________________________________-

- Camera: The camera/view space is all the vertex coordinates seen from the cameras perspective as the orgin of the scene 

- 